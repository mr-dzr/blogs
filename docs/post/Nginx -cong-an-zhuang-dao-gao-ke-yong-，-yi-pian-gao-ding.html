<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="架构文摘 2022-01-23 12:57

## 一、Nginx 安装

### 1、去官网[http://nginx.org/下载对应的 nginx](http://nginx.org/%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%9A%84nginx)包，推荐使用稳定版本

### 2、上传 nginx 到 linux 系统

### 3、安装依赖环境

#### (1)安装 gcc 环境

```shell
yum install gcc-c++
```

#### (2)安装 PCRE 库，用于解析正则表达式

```shell
yum install -y pcre pcre-devel
```

#### (3)zlib 压缩和解压缩依赖

```shell
yum install -y zlib zlib-devel
```

#### (4)SSL 安全的加密的套接字协议层，用于 HTTP 安全传输，也就是 https

```shell
yum install -y openssl openssl-devel
```

### 4、解压，需要注意，解压后得到的是源码，源码需要编译后才能安装

```shell
tar -zxvf nginx-1.16.1.tar.gz
```

### 5、编译之前，先创建 nginx 临时目录，如果不创建，在启动 nginx 的过程中会报错

```shell
mkdir /var/temp/nginx -p
```

### 6、在 nginx 目录，输入如下命令进行配置，目的是为了创建 makefile 文件

```shell
./configure
--prefix=/usr/local/nginx
--pid-path=/var/run/nginx/nginx.pid
--lock-path=/var/lock/nginx.lock
--error-log-path=/var/log/nginx/error.log
--http-log-path=/var/log/nginx/access.log
--with-http_gzip_static_module
--http-client-body-temp-path=/var/temp/nginx/client
--http-proxy-temp-path=/var/temp/nginx/proxy
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi
--http-scgi-temp-path=/var/temp/nginx/scgi
```

注：代表在命令行中换行，用于提高可读性配置命令：

|              命令              |                  解释                  |
| :----------------------------: | :------------------------------------: |
|            --prefix            |            指定 nginx 目录             |
|           --pid-path           |           指定 nginx 的 pid            |
|          --lock-path           |   锁定安装文件，防止恶意篡改或误操作   |
|        --error-log-path        |              错误日志目录              |
|        --http-log-path         |                  日志                  |
| --with-http_gzip_static_module | 启用 gzip 模块，在线实时压缩输出数据流 |
|  --http-client-body-temp-path  |         设置客户端请求临时目录         |
|     --http-proxy-temp-path     |         设置 http 代理临时目录         |
|    --http-fastcgi-temp-path    |          设置 fastcg 临时目录          |
|     --http-uwsgi-temp-path     |          设定 uwsgi 临时目录           |
|     --http-scgi-temp-path      |           设置 scgi 临时目录           |

7、make 编译&安装

```shell
make
make install
```

### 8、进入 sbin 目录启动 nginx

```shell
启动：nginx
停止：./nginx -s stop
重新加载：./nginx -s reload
```

## 二、配置反向代理

### 1、配置 upstream

```shell
upstream [proxyName] {
    server 192.168.1.173:8080;
    server 192.168.1.174:8080;
    server 192.168.1.175:8080;
}
```

### 2、配置 server

```shell
server {
    listem  80;
    server_name www.tomcats.com;    location / {
        proxy_pass http://tomcats;
    }
}
```

## 三、配置负载均衡

nginx 默认采用轮训的方式进行负载均衡

### 1、使用加权轮询

```shell
upstream [proxyName] {
    server 192.168.1.173:8080 weight=1;
    server 192.168.1.174:8080 weight=5;
    server 192.168.1.175:8080 weight=2;
}
```

### 2、hash 负载均衡

```shell
upstream [proxyName] {
    ip_hash
    server 192.168.1.173:8080;
    server 192.168.1.174:8080;
    server 192.168.1.175:8080;
}
```

hash 算法实际上只会计算 192.168.1 这段做哈希

使用 ip_hash 的注意点：

不能把后台服务器直接移除，只能标记 down.

### 3、url hash 负载均衡

```shell
upstream [proxyName] {
    hash $request_url;
    server 192.168.1.173:8080;
    server 192.168.1.174:8080;
    server 192.168.1.175:8080;
}
```

### 4、最小连接负载均衡

```shell
upstream [proxyName] {
    least_conn;
    server 192.168.1.173:8080;
    server 192.168.1.174:8080;
    server 192.168.1.175:8080;
}
```

## 四、upstream 指令参数

`max_conns`：限制最大同时连接数 1.11.5 之前只能用于商业版

`slow_start`：单位秒，权重在指定时间内从 1 上升到指定值，不适用与 hash 负载均衡、随机负载均衡 如果在 upstream 中只有一台 server，则该参数失效（商业版才有）

`down`：禁止访问

`backup`：备用机 只有在其他服务器无法访问的时候才能访问到 不适用与 hash 负载均衡、随机负载均衡

`max_fails`：表示失败几次，则标记 server 已宕机，剔出上游服务 默认值 1

`fail_timeout`：表示失败的重试时间 默认值 10

### 1、keepalived

```shell
upstream [proxyName] {
    server 192.168.1.173:8080 weight=1;
    server 192.168.1.174:8080 weight=5;
    server 192.168.1.175:8080 weight=2;
    keepalive 32; #保持的连接数
}
server {
    listem  80;
    server_name www.tomcats.com;    location / {
        proxy_pass http://tomcats;
        proxy_http_version 1.1; #连接的协议版本
        proxy_set_header Connection ''; 清空连接请求头
    }
}
```

### 2、控制浏览器缓存

```shell
server {
    listem  80;
    server_name www.tomcats.com;

    location / {
        proxy_pass http://tomcats;
               expires 10s;  #浏览器缓存10秒钟
               #expires @22h30m  #在晚上10点30的时候过期
               #expires -1h  #缓存在一小时前时效
               #expires epoch  #不设置缓存
               #expires off  #缓存关闭，浏览器自己控制缓存
               #expires max  #最大过期时间
    }
}
```

### 3、反向代理缓存

```shell
upstream [proxyName] {
    server 192.168.1.173:8080 weight=1;
    server 192.168.1.174:8080 weight=5;
    server 192.168.1.175:8080 weight=2;
}
#proxy_cache_path 设置缓存保存的目录的位置
#keys_zone设置共享内以及占用的空间大小
#mas_size 设置缓存最大空间
#inactive 缓存过期时间，错过此时间自动清理
#use_temp_path 关闭零时目录
proxy_cache_path /usr/local/nginx/upsteam_cache keys_zone=mycache:5m max_size=1g inactive=8h use_temp_path=off;
server {
    listem  80;
    server_name www.tomcats.com;
    #开启并使用缓存
    proxy_cache mycache;
    #针对200和304响应码的缓存过期时间
    proxy_cache_valid 200 304 8h;

    location / {
        proxy_pass http://tomcats;
    }
}
```

## 五、配置 ssl 证书提供 https 访问

### 1. 安装 SSL 模块

要在 nginx 中配置 https，就必须安装 ssl 模块，也就是: `http_ssl_module`。">
<meta property="og:title" content="Nginx 从安装到高可用，一篇搞定">
<meta property="og:description" content="架构文摘 2022-01-23 12:57

## 一、Nginx 安装

### 1、去官网[http://nginx.org/下载对应的 nginx](http://nginx.org/%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%9A%84nginx)包，推荐使用稳定版本

### 2、上传 nginx 到 linux 系统

### 3、安装依赖环境

#### (1)安装 gcc 环境

```shell
yum install gcc-c++
```

#### (2)安装 PCRE 库，用于解析正则表达式

```shell
yum install -y pcre pcre-devel
```

#### (3)zlib 压缩和解压缩依赖

```shell
yum install -y zlib zlib-devel
```

#### (4)SSL 安全的加密的套接字协议层，用于 HTTP 安全传输，也就是 https

```shell
yum install -y openssl openssl-devel
```

### 4、解压，需要注意，解压后得到的是源码，源码需要编译后才能安装

```shell
tar -zxvf nginx-1.16.1.tar.gz
```

### 5、编译之前，先创建 nginx 临时目录，如果不创建，在启动 nginx 的过程中会报错

```shell
mkdir /var/temp/nginx -p
```

### 6、在 nginx 目录，输入如下命令进行配置，目的是为了创建 makefile 文件

```shell
./configure
--prefix=/usr/local/nginx
--pid-path=/var/run/nginx/nginx.pid
--lock-path=/var/lock/nginx.lock
--error-log-path=/var/log/nginx/error.log
--http-log-path=/var/log/nginx/access.log
--with-http_gzip_static_module
--http-client-body-temp-path=/var/temp/nginx/client
--http-proxy-temp-path=/var/temp/nginx/proxy
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi
--http-scgi-temp-path=/var/temp/nginx/scgi
```

注：代表在命令行中换行，用于提高可读性配置命令：

|              命令              |                  解释                  |
| :----------------------------: | :------------------------------------: |
|            --prefix            |            指定 nginx 目录             |
|           --pid-path           |           指定 nginx 的 pid            |
|          --lock-path           |   锁定安装文件，防止恶意篡改或误操作   |
|        --error-log-path        |              错误日志目录              |
|        --http-log-path         |                  日志                  |
| --with-http_gzip_static_module | 启用 gzip 模块，在线实时压缩输出数据流 |
|  --http-client-body-temp-path  |         设置客户端请求临时目录         |
|     --http-proxy-temp-path     |         设置 http 代理临时目录         |
|    --http-fastcgi-temp-path    |          设置 fastcg 临时目录          |
|     --http-uwsgi-temp-path     |          设定 uwsgi 临时目录           |
|     --http-scgi-temp-path      |           设置 scgi 临时目录           |

7、make 编译&安装

```shell
make
make install
```

### 8、进入 sbin 目录启动 nginx

```shell
启动：nginx
停止：./nginx -s stop
重新加载：./nginx -s reload
```

## 二、配置反向代理

### 1、配置 upstream

```shell
upstream [proxyName] {
    server 192.168.1.173:8080;
    server 192.168.1.174:8080;
    server 192.168.1.175:8080;
}
```

### 2、配置 server

```shell
server {
    listem  80;
    server_name www.tomcats.com;    location / {
        proxy_pass http://tomcats;
    }
}
```

## 三、配置负载均衡

nginx 默认采用轮训的方式进行负载均衡

### 1、使用加权轮询

```shell
upstream [proxyName] {
    server 192.168.1.173:8080 weight=1;
    server 192.168.1.174:8080 weight=5;
    server 192.168.1.175:8080 weight=2;
}
```

### 2、hash 负载均衡

```shell
upstream [proxyName] {
    ip_hash
    server 192.168.1.173:8080;
    server 192.168.1.174:8080;
    server 192.168.1.175:8080;
}
```

hash 算法实际上只会计算 192.168.1 这段做哈希

使用 ip_hash 的注意点：

不能把后台服务器直接移除，只能标记 down.

### 3、url hash 负载均衡

```shell
upstream [proxyName] {
    hash $request_url;
    server 192.168.1.173:8080;
    server 192.168.1.174:8080;
    server 192.168.1.175:8080;
}
```

### 4、最小连接负载均衡

```shell
upstream [proxyName] {
    least_conn;
    server 192.168.1.173:8080;
    server 192.168.1.174:8080;
    server 192.168.1.175:8080;
}
```

## 四、upstream 指令参数

`max_conns`：限制最大同时连接数 1.11.5 之前只能用于商业版

`slow_start`：单位秒，权重在指定时间内从 1 上升到指定值，不适用与 hash 负载均衡、随机负载均衡 如果在 upstream 中只有一台 server，则该参数失效（商业版才有）

`down`：禁止访问

`backup`：备用机 只有在其他服务器无法访问的时候才能访问到 不适用与 hash 负载均衡、随机负载均衡

`max_fails`：表示失败几次，则标记 server 已宕机，剔出上游服务 默认值 1

`fail_timeout`：表示失败的重试时间 默认值 10

### 1、keepalived

```shell
upstream [proxyName] {
    server 192.168.1.173:8080 weight=1;
    server 192.168.1.174:8080 weight=5;
    server 192.168.1.175:8080 weight=2;
    keepalive 32; #保持的连接数
}
server {
    listem  80;
    server_name www.tomcats.com;    location / {
        proxy_pass http://tomcats;
        proxy_http_version 1.1; #连接的协议版本
        proxy_set_header Connection ''; 清空连接请求头
    }
}
```

### 2、控制浏览器缓存

```shell
server {
    listem  80;
    server_name www.tomcats.com;

    location / {
        proxy_pass http://tomcats;
               expires 10s;  #浏览器缓存10秒钟
               #expires @22h30m  #在晚上10点30的时候过期
               #expires -1h  #缓存在一小时前时效
               #expires epoch  #不设置缓存
               #expires off  #缓存关闭，浏览器自己控制缓存
               #expires max  #最大过期时间
    }
}
```

### 3、反向代理缓存

```shell
upstream [proxyName] {
    server 192.168.1.173:8080 weight=1;
    server 192.168.1.174:8080 weight=5;
    server 192.168.1.175:8080 weight=2;
}
#proxy_cache_path 设置缓存保存的目录的位置
#keys_zone设置共享内以及占用的空间大小
#mas_size 设置缓存最大空间
#inactive 缓存过期时间，错过此时间自动清理
#use_temp_path 关闭零时目录
proxy_cache_path /usr/local/nginx/upsteam_cache keys_zone=mycache:5m max_size=1g inactive=8h use_temp_path=off;
server {
    listem  80;
    server_name www.tomcats.com;
    #开启并使用缓存
    proxy_cache mycache;
    #针对200和304响应码的缓存过期时间
    proxy_cache_valid 200 304 8h;

    location / {
        proxy_pass http://tomcats;
    }
}
```

## 五、配置 ssl 证书提供 https 访问

### 1. 安装 SSL 模块

要在 nginx 中配置 https，就必须安装 ssl 模块，也就是: `http_ssl_module`。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://mr-dzr.github.io/blogs/post/Nginx%20-cong-an-zhuang-dao-gao-ke-yong-%EF%BC%8C-yi-pian-gao-ding.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>Nginx 从安装到高可用，一篇搞定</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Nginx 从安装到高可用，一篇搞定</h1>
<div class="title-right">
    <a href="https://mr-dzr.github.io/blogs" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/mr-dzr/blogs/issues/1" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p>架构文摘 2022-01-23 12:57</p>
<h2>一、Nginx 安装</h2>
<h3>1、去官网<a href="http://nginx.org/%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%9A%84nginx" rel="nofollow">http://nginx.org/下载对应的 nginx</a>包，推荐使用稳定版本</h3>
<h3>2、上传 nginx 到 linux 系统</h3>
<h3>3、安装依赖环境</h3>
<h4>(1)安装 gcc 环境</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">yum install gcc-c++</pre></div>
<h4>(2)安装 PCRE 库，用于解析正则表达式</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">yum install -y pcre pcre-devel</pre></div>
<h4>(3)zlib 压缩和解压缩依赖</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">yum install -y zlib zlib-devel</pre></div>
<h4>(4)SSL 安全的加密的套接字协议层，用于 HTTP 安全传输，也就是 https</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">yum install -y openssl openssl-devel</pre></div>
<h3>4、解压，需要注意，解压后得到的是源码，源码需要编译后才能安装</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">tar -zxvf nginx-1.16.1.tar.gz</pre></div>
<h3>5、编译之前，先创建 nginx 临时目录，如果不创建，在启动 nginx 的过程中会报错</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">mkdir /var/temp/nginx -p</pre></div>
<h3>6、在 nginx 目录，输入如下命令进行配置，目的是为了创建 makefile 文件</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">./configure
--prefix=/usr/local/nginx
--pid-path=/var/run/nginx/nginx.pid
--lock-path=/var/lock/nginx.lock
--error-log-path=/var/log/nginx/error.log
--http-log-path=/var/log/nginx/access.log
--with-http_gzip_static_module
--http-client-body-temp-path=/var/temp/nginx/client
--http-proxy-temp-path=/var/temp/nginx/proxy
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi
--http-scgi-temp-path=/var/temp/nginx/scgi</pre></div>
<p>注：代表在命令行中换行，用于提高可读性配置命令：</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th align="center">命令</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">--prefix</td>
<td align="center">指定 nginx 目录</td>
</tr>
<tr>
<td align="center">--pid-path</td>
<td align="center">指定 nginx 的 pid</td>
</tr>
<tr>
<td align="center">--lock-path</td>
<td align="center">锁定安装文件，防止恶意篡改或误操作</td>
</tr>
<tr>
<td align="center">--error-log-path</td>
<td align="center">错误日志目录</td>
</tr>
<tr>
<td align="center">--http-log-path</td>
<td align="center">日志</td>
</tr>
<tr>
<td align="center">--with-http_gzip_static_module</td>
<td align="center">启用 gzip 模块，在线实时压缩输出数据流</td>
</tr>
<tr>
<td align="center">--http-client-body-temp-path</td>
<td align="center">设置客户端请求临时目录</td>
</tr>
<tr>
<td align="center">--http-proxy-temp-path</td>
<td align="center">设置 http 代理临时目录</td>
</tr>
<tr>
<td align="center">--http-fastcgi-temp-path</td>
<td align="center">设置 fastcg 临时目录</td>
</tr>
<tr>
<td align="center">--http-uwsgi-temp-path</td>
<td align="center">设定 uwsgi 临时目录</td>
</tr>
<tr>
<td align="center">--http-scgi-temp-path</td>
<td align="center">设置 scgi 临时目录</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>7、make 编译&amp;安装</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">make
make install</pre></div>
<h3>8、进入 sbin 目录启动 nginx</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">启动：nginx
停止：./nginx -s stop
重新加载：./nginx -s reload</pre></div>
<h2>二、配置反向代理</h2>
<h3>1、配置 upstream</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">upstream [proxyName] {
    server 192.168.1.173:8080<span class="pl-k">;</span>
    server 192.168.1.174:8080<span class="pl-k">;</span>
    server 192.168.1.175:8080<span class="pl-k">;</span>
}</pre></div>
<h3>2、配置 server</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">server {
    listem  80<span class="pl-k">;</span>
    server_name www.tomcats.com<span class="pl-k">;</span>    location / {
        proxy_pass http://tomcats<span class="pl-k">;</span>
    }
}</pre></div>
<h2>三、配置负载均衡</h2>
<p>nginx 默认采用轮训的方式进行负载均衡</p>
<h3>1、使用加权轮询</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">upstream [proxyName] {
    server 192.168.1.173:8080 weight=1<span class="pl-k">;</span>
    server 192.168.1.174:8080 weight=5<span class="pl-k">;</span>
    server 192.168.1.175:8080 weight=2<span class="pl-k">;</span>
}</pre></div>
<h3>2、hash 负载均衡</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">upstream [proxyName] {
    ip_hash
    server 192.168.1.173:8080<span class="pl-k">;</span>
    server 192.168.1.174:8080<span class="pl-k">;</span>
    server 192.168.1.175:8080<span class="pl-k">;</span>
}</pre></div>
<p>hash 算法实际上只会计算 192.168.1 这段做哈希</p>
<p>使用 ip_hash 的注意点：</p>
<p>不能把后台服务器直接移除，只能标记 down.</p>
<h3>3、url hash 负载均衡</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">upstream [proxyName] {
    <span class="pl-c1">hash</span> <span class="pl-smi">$request_url</span><span class="pl-k">;</span>
    server 192.168.1.173:8080<span class="pl-k">;</span>
    server 192.168.1.174:8080<span class="pl-k">;</span>
    server 192.168.1.175:8080<span class="pl-k">;</span>
}</pre></div>
<h3>4、最小连接负载均衡</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">upstream [proxyName] {
    least_conn<span class="pl-k">;</span>
    server 192.168.1.173:8080<span class="pl-k">;</span>
    server 192.168.1.174:8080<span class="pl-k">;</span>
    server 192.168.1.175:8080<span class="pl-k">;</span>
}</pre></div>
<h2>四、upstream 指令参数</h2>
<p><code class="notranslate">max_conns</code>：限制最大同时连接数 1.11.5 之前只能用于商业版</p>
<p><code class="notranslate">slow_start</code>：单位秒，权重在指定时间内从 1 上升到指定值，不适用与 hash 负载均衡、随机负载均衡 如果在 upstream 中只有一台 server，则该参数失效（商业版才有）</p>
<p><code class="notranslate">down</code>：禁止访问</p>
<p><code class="notranslate">backup</code>：备用机 只有在其他服务器无法访问的时候才能访问到 不适用与 hash 负载均衡、随机负载均衡</p>
<p><code class="notranslate">max_fails</code>：表示失败几次，则标记 server 已宕机，剔出上游服务 默认值 1</p>
<p><code class="notranslate">fail_timeout</code>：表示失败的重试时间 默认值 10</p>
<h3>1、keepalived</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">upstream [proxyName] {
    server 192.168.1.173:8080 weight=1<span class="pl-k">;</span>
    server 192.168.1.174:8080 weight=5<span class="pl-k">;</span>
    server 192.168.1.175:8080 weight=2<span class="pl-k">;</span>
    keepalive 32<span class="pl-k">;</span> <span class="pl-c"><span class="pl-c">#</span>保持的连接数</span>
}
server {
    listem  80<span class="pl-k">;</span>
    server_name www.tomcats.com<span class="pl-k">;</span>    location / {
        proxy_pass http://tomcats<span class="pl-k">;</span>
        proxy_http_version 1.1<span class="pl-k">;</span> <span class="pl-c"><span class="pl-c">#</span>连接的协议版本</span>
        proxy_set_header Connection <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span><span class="pl-k">;</span> 清空连接请求头
    }
}</pre></div>
<h3>2、控制浏览器缓存</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">server {
    listem  80<span class="pl-k">;</span>
    server_name www.tomcats.com<span class="pl-k">;</span>

    location / {
        proxy_pass http://tomcats<span class="pl-k">;</span>
               expires 10s<span class="pl-k">;</span>  <span class="pl-c"><span class="pl-c">#</span>浏览器缓存10秒钟</span>
               <span class="pl-c"><span class="pl-c">#</span>expires @22h30m  #在晚上10点30的时候过期</span>
               <span class="pl-c"><span class="pl-c">#</span>expires -1h  #缓存在一小时前时效</span>
               <span class="pl-c"><span class="pl-c">#</span>expires epoch  #不设置缓存</span>
               <span class="pl-c"><span class="pl-c">#</span>expires off  #缓存关闭，浏览器自己控制缓存</span>
               <span class="pl-c"><span class="pl-c">#</span>expires max  #最大过期时间</span>
    }
}</pre></div>
<h3>3、反向代理缓存</h3>
<div class="highlight highlight-source-shell"><pre class="notranslate">upstream [proxyName] {
    server 192.168.1.173:8080 weight=1<span class="pl-k">;</span>
    server 192.168.1.174:8080 weight=5<span class="pl-k">;</span>
    server 192.168.1.175:8080 weight=2<span class="pl-k">;</span>
}
<span class="pl-c"><span class="pl-c">#</span>proxy_cache_path 设置缓存保存的目录的位置</span>
<span class="pl-c"><span class="pl-c">#</span>keys_zone设置共享内以及占用的空间大小</span>
<span class="pl-c"><span class="pl-c">#</span>mas_size 设置缓存最大空间</span>
<span class="pl-c"><span class="pl-c">#</span>inactive 缓存过期时间，错过此时间自动清理</span>
<span class="pl-c"><span class="pl-c">#</span>use_temp_path 关闭零时目录</span>
proxy_cache_path /usr/local/nginx/upsteam_cache keys_zone=mycache:5m max_size=1g inactive=8h use_temp_path=off<span class="pl-k">;</span>
server {
    listem  80<span class="pl-k">;</span>
    server_name www.tomcats.com<span class="pl-k">;</span>
    <span class="pl-c"><span class="pl-c">#</span>开启并使用缓存</span>
    proxy_cache mycache<span class="pl-k">;</span>
    <span class="pl-c"><span class="pl-c">#</span>针对200和304响应码的缓存过期时间</span>
    proxy_cache_valid 200 304 8h<span class="pl-k">;</span>

    location / {
        proxy_pass http://tomcats<span class="pl-k">;</span>
    }
}</pre></div>
<h2>五、配置 ssl 证书提供 https 访问</h2>
<h3>1. 安装 SSL 模块</h3>
<p>要在 nginx 中配置 https，就必须安装 ssl 模块，也就是: <code class="notranslate">http_ssl_module</code>。</p>
<p>进入到 nginx 的解压目录：<code class="notranslate">/home/software/nginx-1.16.1</code></p>
<p>新增 ssl 模块(原来的那些模块需要保留)</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">./configure --prefix=/usr/local/nginx
--pid-path=/var/run/nginx/nginx.pid
--lock-path=/var/lock/nginx.lock
--error-log-path=/var/log/nginx/error.log
--http-log-path=/var/log/nginx/access.log
--with-http_gzip_static_module
--http-client-body-temp-path=/var/temp/nginx/client
--http-proxy-temp-path=/var/temp/nginx/proxy
--http-fastcgi-temp-path=/var/temp/nginx/fastcgi
--http-uwsgi-temp-path=/var/temp/nginx/uwsgi
--http-scgi-temp-path=/var/temp/nginx/scgi
--with-http_ssl_module</pre></div>
<p>编译和安装</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">make
make install</pre></div>
<h3>2、配置 HTTPS</h3>
<p>把 ssl 证书 <em>.crt 和 私钥</em>.key 拷贝到/usr/local/nginx/conf 目录中。</p>
<p>新增 server 监听 443 端口：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">server {
listen 443<span class="pl-k">;</span>
server_name www.imoocdsp.com<span class="pl-k">;</span> <span class="pl-c"><span class="pl-c">#</span> 开启 ssl</span>
ssl on<span class="pl-k">;</span> <span class="pl-c"><span class="pl-c">#</span> 配置 ssl 证书</span>
ssl_certificate 1_www.imoocdsp.com_bundle.crt<span class="pl-k">;</span> <span class="pl-c"><span class="pl-c">#</span> 配置证书秘钥</span>
ssl_certificate_key 2<span class="pl-cce">\_</span>www.imoocdsp.com.key<span class="pl-k">;</span> <span class="pl-c"><span class="pl-c">#</span> ssl 会话 cache</span>
ssl_session_cache shared:SSL:1m<span class="pl-k">;</span> <span class="pl-c"><span class="pl-c">#</span> ssl 会话超时时间</span>
ssl_session_timeout 5m<span class="pl-k">;</span> <span class="pl-c"><span class="pl-c">#</span> 配置加密套件，写法遵循 openssl 标准</span>
ssl_protocols TLSv1 TLSv1.1 TLSv1.2<span class="pl-k">;</span>
ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:<span class="pl-k">!</span>aNULL:<span class="pl-k">!</span>MD5:<span class="pl-k">!</span>RC4:<span class="pl-k">!</span>DHE<span class="pl-k">;</span>
ssl_prefer_server_ciphers on<span class="pl-k">;</span>
location / {
        proxy_pass http://tomcats/<span class="pl-k">;</span>
        index  index.html index.htm<span class="pl-k">;</span>
    }}</pre></div>
<h2>六、配置 ha nginx</h2>
<h3>1、安装 keepalived</h3>
<h4>(1)下载</h4>
<div class="highlight highlight-source-httpspec"><pre class="notranslate"><span class="pl-ii">https://www.keepalived.org/download.html</span></pre></div>
<h4>(2)解压</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">tar -zxvf keepalived-2.0.18.tar.gz</pre></div>
<h4>(3)使用 configure 命令配置安装目录与核心配置文件所在位置：</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">./configure --prefix=/usr/local/keepalived --sysconf=/etc</pre></div>
<p><code class="notranslate">prefix</code>：keepalived 安装的位置 sysconf：keepalived 核心配置文件所在位置，固定位置，改成其他位置则 keepalived 启动不了，<code class="notranslate">/var/log/messages</code>中会报错</p>
<p><code class="notranslate">sysconf</code>：keepalived 核心配置文件所在位置，固定位置，改成其他位置则 keepalived 启动不了，<code class="notranslate">/var/log/messages</code> 中会报错</p>
<p>配置过程中可能会出现警告信息，如下所示：</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-k">***</span> WARNING - this build will not support IPVS with IPv6. Please install libnl/libnl-3 dev libraries to support IPv6 with IPVS.
<span class="pl-c"><span class="pl-c">#</span> 安装 libnl/libnl-3 依赖</span>
yum -y install libnl libnl-devel</pre></div>
<h4>(4)安装 keepalived</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">make <span class="pl-k">&amp;&amp;</span> make install</pre></div>
<h4>(5)配置文件 在 <code class="notranslate">/etc/keepalived/keepalived.conf</code></h4>
<h4>(6)忘记安装配置的目录，则通过如下命令找到：</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">whereis keepalived</pre></div>
<h4>(7)启动 keepalived</h4>
<p>进入 sbin 目录</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">./keepalived</pre></div>
<h3>2、配置 keepalived 主机</h3>
<h4>(1)通过命令 vim keepalived.conf 打开配置文件</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">global_defs {
 <span class="pl-c"><span class="pl-c">#</span> 路由 id：当前安装 keepalived 的节点主机标识符，保证全局唯一</span>
 router_id keep_171
}
vrrp_instance VI_1 {
    <span class="pl-c"><span class="pl-c">#</span> 表示状态是 MASTER 主机还是备用机 BACKUP</span>
    state MASTER
    <span class="pl-c"><span class="pl-c">#</span> 该实例绑定的网卡</span>
    interface ens33
    <span class="pl-c"><span class="pl-c">#</span> 保证主备节点一致即可</span>
    virtual_router_id 51
    <span class="pl-c"><span class="pl-c">#</span> 权重，master 权重一般高于 backup，如果有多个，那就是选举，谁的权重高，谁就当选</span>
    priority 100
    <span class="pl-c"><span class="pl-c">#</span> 主备之间同步检查时间间隔，单位秒</span>
    advert_int 2
    <span class="pl-c"><span class="pl-c">#</span> 认证权限密码，防止非法节点进入</span>
    authentication {
    auth_type PASS
    auth_pass 1111
    }
    <span class="pl-c"><span class="pl-c">#</span> 虚拟出来的 ip，可以有多个（vip）</span>
    virtual_ipaddress {
        192.168.1.161
    }
}</pre></div>
<p>附：查看网卡信息命令</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">ip addr</pre></div>
<h4>(2)启动 keepalived</h4>
<h4>(3)查看进程</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">ps -ef<span class="pl-k">|</span>grep keepalived</pre></div>
<h4>(4)查看 vip(虚拟 ip)</h4>
<p>在网卡 ens33 下，多了一个 <code class="notranslate">192.168.1.161</code>，这个就是虚拟 ip</p>
<h3>3、把 keepalived 注册为系统服务</h3>
<h4>(1)拷贝配置文件</h4>
<p>将 keepalived 目录下 <code class="notranslate">etc/init.d/keepalived</code> 拷贝到 <code class="notranslate">/etc/init.d/</code>下<br>
将 keepalived 目录下 <code class="notranslate">etc/sysconfig/keepalived</code> 拷贝到 <code class="notranslate">/etc/sysconfig/</code>下</p>
<h4>(2)刷新 systemctl</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">systemctl daemon-reload</pre></div>
<h4>(3)启动、停止、重启 keepalived</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 启动</span>
systemctl start keepalived.service
<span class="pl-c"><span class="pl-c">#</span>停止</span>
systemctl stop keepalived.service
<span class="pl-c"><span class="pl-c">#</span>重启</span>
systemctl restart keepalived.service</pre></div>
<h3>4、实现双机主备高可用</h3>
<p><a target="_blank" rel="noopener noreferrer" href="image/Nginx%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8/1642990547451.png"><img src="image/Nginx%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8/1642990547451.png" alt="实现双机主备高可用" title="实现双机主备高可用" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-mermaid"><pre class="notranslate"><span class="pl-k">graph</span> <span class="pl-c1">TB</span>
    <span class="pl-ent">c1</span><span class="pl-k">--&gt;</span><span class="pl-ent">a2</span>
    <span class="pl-k">subgraph</span> <span class="pl-en">one</span>
    <span class="pl-ent">a1</span><span class="pl-k">--&gt;</span><span class="pl-ent">a2</span>
    <span class="pl-k">end</span>
    <span class="pl-k">subgraph</span> <span class="pl-en">two</span>
    <span class="pl-ent">b1</span><span class="pl-k">--&gt;</span><span class="pl-ent">b2</span>
    <span class="pl-k">end</span>
    <span class="pl-k">subgraph</span> <span class="pl-en">three</span>
    <span class="pl-ent">c1</span><span class="pl-k">--&gt;</span><span class="pl-ent">c2</span>
    <span class="pl-k">end</span></pre></div>
<h4>(1)修改备机配置</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">global_defs {
    router_id keep_172
}
vrrp_instance VI_1 {
    <span class="pl-c"><span class="pl-c">#</span> 备用机设置为 BACKUP</span>
    state BACKUP
    interface ens33
    virtual_router_id 51
    <span class="pl-c"><span class="pl-c">#</span> 权重低于 MASTER</span>
    priority 80
    advert_int 2
    authentication {
    auth_type PASS auth_pass 1111
    }
    virtual_ipaddress {
        <span class="pl-c"><span class="pl-c">#</span> 注意：主备两台的 vip 都是一样的，绑定到同一个 vip</span>
        192.168.1.161
    }
}</pre></div>
<h4>(2) 启动 Keepalived</h4>
<h4>(3) 访问 vip 即可访问主机，当主机失效时访问 vip 就会访问到备机</h4>
<h3>5、keepalived 配置 nginx 自动重启</h3>
<h4>(1)编写脚本</h4>
<p>在 <code class="notranslate">/etc/keepalived/</code>下创建脚本 <code class="notranslate">check_nginx_alive_or_not</code></p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#!</span>/bin/bash</span>

A=<span class="pl-s"><span class="pl-pds">`</span>ps -C nginx --no-header <span class="pl-k">|</span>wc -l<span class="pl-pds">`</span></span>

<span class="pl-c"><span class="pl-c">#</span> 判断 nginx 是否宕机，如果宕机了，尝试重启</span>

<span class="pl-k">if</span> [ <span class="pl-smi">$A</span> <span class="pl-k">-eq</span> 0 ]<span class="pl-k">;</span><span class="pl-k">then</span>
/usr/local/nginx/sbin/nginx <span class="pl-c"><span class="pl-c">#</span> 等待一小会再次检查 nginx，如果没有启动成功，则停止 keepalived，使其启动备用机</span>
sleep 3
<span class="pl-k">if</span> [ <span class="pl-s"><span class="pl-pds">`</span>ps -C nginx --no-header <span class="pl-k">|</span>wc -l<span class="pl-pds">`</span></span> <span class="pl-k">-eq</span> 0 ]<span class="pl-k">;</span><span class="pl-k">then</span>
killall keepalived
<span class="pl-k">fi</span>
<span class="pl-k">fi</span></pre></div>
<h4>(2)添加运行权限</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">chmod +x /etc/keepalived/check_nginx_alive_or_not.sh</pre></div>
<h4>(3)配置 keepalived 监听 nginx 脚本</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">vrrp_script check_nginx_alive {
script <span class="pl-s"><span class="pl-pds">"</span>/etc/keepalived/check_nginx_alive_or_not.sh<span class="pl-pds">"</span></span>
interval 2 <span class="pl-c"><span class="pl-c">#</span> 每隔两秒运行上一行脚本</span>
weight 10 <span class="pl-c"><span class="pl-c">#</span> 如果脚本运行失败，则升级权重+10</span>
}</pre></div>
<h4>(4)在 vrrp_instance 中新增监控的脚本</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">track_script {
check_nginx_alive <span class="pl-c"><span class="pl-c">#</span> 追踪 nginx 脚本</span>
}</pre></div>
<h4>(5)重启 Keepalived 使得配置文件生效</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">systemctl restart keepalived</pre></div>
<h3>6、keepalived 双主热备</h3>
<h4>(1)配置 DNS 轮询</h4>
<p>在同一个域名下配置两个 ip，自行百度</p>
<h4>(2)配置第一台主机</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">global_defs {
    router_id keep_171
}
vrrp_instance VI_1 {
    state MASTER i
    nterface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.1.161
    }
}

vrrp_instance VI_2 {
    state BACKUP
    interface ens33
    virtual_router_id 52
    priority 80
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.1.162
    }
}</pre></div>
<h4>(3)配置第二台主机</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">global_defs {
    router_id keep_172
}
vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id 51
    priority 80
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.1.161
    }
}

vrrp_instance VI_2 {
    state MASTER
    interface ens33
    virtual_router_id 52
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
       192.168.1.162
    }
}</pre></div>
<h4>(4)重启两台 Keepalived</h4>
<div class="highlight highlight-source-shell"><pre class="notranslate">systemctl restart keepalived</pre></div>
<h2>七、LVS（Linux Virtual Server）实现高可用负载均衡</h2>
<h3>1、为什么要使用 LVS+Nginx</h3>
<p>lvs 基于四层负载均衡，工作效率较 Nginx 的七层负载更高，使用 LVS 搭建 Nginx 集群，可以提高性能<br>
四层负载均衡无法对信息处理，只能通过 ip+端口的形式转发，所以需要七成负载进行数据的处理<br>
Nginx 接收请求来回，LVS 可以只接受不响应</p>
<h3>2、LVS 的三种模式</h3>
<h4>(1)NAT 模式</h4>
<p>客户端将请求发往 LVS，LVS 会选择一台服务器响应请求，服务器将结果返回给 LVS，LVS 再返回给客户端。<br>
在 NAT 模式中，服务器的网关必须指向 LVS，否则报文无法送达客户端<br>
NAT 技术将请求的报文和响应的报文都需要通过 LVS 进行地址改写，因此网站访问量比较大的时候负载均衡调度器有比较大的瓶颈，一般要求最多之能 10-20 台节点<br>
NAT 模式支持对 IP 地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致</p>
<h4>(2)TUN 模式</h4>
<p>客户端将请求发往 LVS，LVS 会选择一台服务器响应请求，在客户端与服务器之间建立隧道，返回结果的时候直接由服务器返回响应，不在经过 LVS。<br>
TUN 模式必须所有的服务器上都绑定 VIP 的 IP 地址，所有的服务器都必须有网卡。<br>
TUN 模式走隧道运维难度大，并且会直接暴露服务器地址<br>
服务器将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多服务器进行分发。而且跑在公网上就能进行不同地域的分发</p>
<h4>(3)DR 模式</h4>
<p>客户端将请求发往 LVS，LVS 会选择一台服务器响应请求，返回结果的时候通过统一的路由进行返回，不在经过 LVS。<br>
和 TUN 模式一样，LVS 只是分发请求，应答包通过单独的路由返回给客户端，与 TUN 相比这种方式不需要隧道结构，可以兼容大多数的操作系统，同时统一路由可以隐藏真实的物理服务器。DR 模式效率更高，但配置更复杂.<br>
所有服务器节点和 LVS 只能在一个局域网里面。</p>
<h3>3、搭建 LVS-DR 模式</h3>
<p>先关闭掉服务器上网络配置管理器，避免网络接口冲突</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">systemctl stop NetworkManager
systemctl disable NetworkManager</pre></div>
<h4>(1)创建子接口（创建 LVS 的虚拟 ip）</h4>
<p>进入网卡配置目录/etc/sysconfig/network-scripts/,找到网卡配置文件，这里以 ifcfg-ens33 为例，拷贝并创建子接口</p>
<p>cp ifcfg-ens33 ifcfg-ens33:1<br>
修改子接口配置如下</p>
<p>配置中的 192.168.1.150 就是 vip，是提供给外网用户访问的 ip 地址</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">DEVICE=<span class="pl-s"><span class="pl-pds">"</span>ens33:1<span class="pl-pds">"</span></span>
ONBOOT=<span class="pl-s"><span class="pl-pds">"</span>yes<span class="pl-pds">"</span></span>
IPADDR=192.168.1.150
NETMASK=255.255.255.0
BOOTPROTO=static</pre></div>
<p>重启网络服务</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">service network restart</pre></div>
<p>重启成功后，ip addr 查看一下，你会发现多了一个 ip，也就是虚拟 ip（vip）</p>
<p>注意：阿里云不支持配置网卡，需要购买相应的负载均衡服务，腾讯云支持配置网卡，但需要购买网卡支持，一个网卡支持 10 个虚拟 ip 配置</p>
<h4>(2)安装 ipvsadm</h4>
<p>如今的 centos 都集成了 LVS，所以 ipvs 是自带的，我们只需要安装 ipvsadm 即可（ipvsadm 是管理集群的工具，通过 ipvs 可以管理集群，查看集群等操作）</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">yum install ipvsadm</pre></div>
<h4>(3)配置服务器（RS）的虚拟 ip</h4>
<p>进入网卡配置目录/etc/sysconfig/network-scripts/,找到 ifcfg-lo，拷贝并创建子接口</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">cp ifcfg-lo ifcfg-lo:1</pre></div>
<p>修改子接口配置如下</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">DEVICE=<span class="pl-s"><span class="pl-pds">"</span>lo:1<span class="pl-pds">"</span></span>
IPADDR=192.168.1.150
NETMASK=255.255.255.255
NETWORK=127.0.0.0
BROADCAST=127.255.255.255
ONBOOT=<span class="pl-s"><span class="pl-pds">"</span>yes<span class="pl-pds">"</span></span>
NAME=loopback</pre></div>
<p>重启网络服务成功后，ip addr 查看一下，你会发现多了一个 ip，也就是虚拟 ip（vip）</p>
<h4>(4)为服务器（RS）配置 arp</h4>
<p>ARP 响应级别与通告行为参数说明</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">arp-ignore：ARP 响应级别（处理请求）
0：只要本机配置了 ip，就能响应请求
1：请求的目标地址到达对应的网络接口，才会响应请求
arp-announce：ARP 通告行为（返回响应）
0：本机上任何网络接口都向外通告，所有的网卡都能接受到通告
1：尽可能避免本网卡与不匹配的目标进行通告 2：只在本网卡通告</pre></div>
<p>打开 sysctl.conf:</p>
<p>vim /etc/sysctl.conf<br>
配置所有网卡、默认网卡以及虚拟网卡的 arp 响应级别和通告行为，分别对应：all，default，lo</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> configration for lvs</span>

net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1

net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_announce = 2</pre></div>
<p>刷新配置文件</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">sysctl -p</pre></div>
<p>增加一个网关，用于接收数据报文，当有请求到本机后，会交给 lo 去处理</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">route add -host 192.168.1.150 dev lo:1</pre></div>
<p>将网关添加至开机启动</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c1">echo</span> <span class="pl-s"><span class="pl-pds">"</span>route add -host 192.168.1.150 dev lo:1<span class="pl-pds">"</span></span> <span class="pl-k">&gt;&gt;</span> /etc/rc.local</pre></div>
<h4>(4)使用 ipvsadm 配置集群规则</h4>
<p>创建 LVS 节点，用户访问的集群调度者</p>
<p>ipvsadm -A -t 192.168.1.150:80 -s rr -p 5<br>
<code class="notranslate">-A</code>：添加集群<br>
<code class="notranslate">-t</code>：tcp 协议 ip 地址：设定集群的访问<br>
<code class="notranslate">ip</code>：也就是 LVS 的虚拟 ip<br>
<code class="notranslate">-s</code>：设置负载均衡的算法，<br>
<code class="notranslate">rr</code>：表示轮询<br>
<code class="notranslate">-p</code>：设置连接持久化的时间,在指定时间内同一个用户的请求会访问到同一个服务器中<br>
创建多台 RS 真实服务器</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">ipvsadm -a -t 192.168.1.150:80 -r 192.168.1.171:80 -g
ipvsadm -a -t 192.168.1.150:80 -r 192.168.1.172:80 -g</pre></div>
<p><code class="notranslate">-a</code>：添加真实服务器<br>
<code class="notranslate">-t</code>：tcp 协议<br>
<code class="notranslate">-r</code>：真实服务器的 ip 地址<br>
<code class="notranslate">-g</code>：设定 DR 模式<br>
保存到规则库，否则重启失效</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">ipvsadm -S</pre></div>
<p>检查集群</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 查看集群列表</span>
ipvsadm -Ln
 <span class="pl-c"><span class="pl-c">#</span>查看集群状态</span>
ipvsadm -Ln --stats</pre></div>
<p>一些其他命令</p>
<div class="highlight highlight-source-shell"><pre class="notranslate"><span class="pl-c"><span class="pl-c">#</span> 重启 ipvsadm，重启后需要重新配置</span>

service ipvsadm restart

<span class="pl-c"><span class="pl-c">#</span> 查看持久化连接</span>

ipvsadm -Ln --persistent-conn

<span class="pl-c"><span class="pl-c">#</span> 查看连接请求过期时间以及请求源 ip 和目标 ip</span>

ipvsadm -Lnc

<span class="pl-c"><span class="pl-c">#</span> 设置 tcp tcpfin udp 的过期时间（一般保持默认）</span>

ipvsadm --set 1 1 1

<span class="pl-c"><span class="pl-c">#</span> 查看过期时间</span>

ipvsadm -Ln --timeout
</pre></div>
<h4>(5)访问虚拟 ip，完成 LVS 搭建</h4>
<h4>附：LVS 的负载均衡算法</h4>
<h5>(1)静态算法</h5>
<p>静态：根据 LVS 本身自由的固定的算法分发用户请求。</p>
<p>轮询（Round Robin 简写’rr’）：轮询算法假设所有的服务器处理请求的能力都一样的，调度器会把所有的请求平均分配给每个真实服务器。（同 Nginx 的轮询）<br>
加权轮询（Weight Round Robin 简写’wrr’）：安装权重比例分配用户请求。权重越高，被分配到处理的请求越多。（同 Nginx 的权重）<br>
源地址散列（Source Hash 简写’sh’）：同一个用户 ip 的请求，会由同一个 RS 来处理。（同 Nginx 的 ip_hash）<br>
目标地址散列（Destination Hash 简写’dh’）：根据 url 的不同，请求到不同的 RS。（同 Nginx 的 url_hash）</p>
<h5>(2)动态算法</h5>
<p>动态：会根据流量的不同，或者服务器的压力不同来分配用户请求，这是动态计算的。</p>
<p>最小连接数（Least Connections 简写’lc’）：把新的连接请求分配到当前连接数最小的服务器。<br>
加权最少连接数（Weight Least Connections 简写’wlc’）：服务器的处理性能用数值来代表，权重越大处理的请求越多。Real Server 有可能会存在性能上的差异，wlc 动态获取不同服务器的负载状况，把请求分发到性能好并且比较空闲的服务器。<br>
最短期望延迟（Shortest Expected Delay 简写’sed’）：特殊的 wlc 算法。举例阐述，假设有 ABC 三台服务器，权重分别为 1、2、3 。如果使用 wlc 算法的话，当一个新请求进来，它可能会分给 ABC 中的任意一个。使用 sed 算法后会进行如下运算：<br>
A：（1+1）/1=2<br>
B：（1+2）/2=3/2<br>
C：（1+3）/3=4/3<br>
最终结果，会把这个请求交给得出运算结果最小的服务器。最少队列调度（Never Queue 简写’nq’）：永不使用队列。如果有 Real Server 的连接数等于 0，则直接把这个请求分配过去，不需要在排队等待运算了（sed 运算）。</p>
<h2>八、搭建 Keepalived+Lvs+Nginx 高可用集群负载均衡</h2>
<p>如果原先服务器上配置了 LVS+nginx 需要清空 ipvsadm 中的配置</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">ipvsadm -C</pre></div>
<p>如果配置了 Keepalived+Nginx 双主集群也需要去除掉 Keepalived 中原先的配置，按照的后文进行配置</p>
<h3>(1)使用 keepalived 配置 Master LVS</h3>
<p>在 LVS 的机器上安装 keepalived，安装过程参考上文</p>
<p>(1)修改 keepalived 的配置</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">global_defs {
router_id keep_151
}
vrrp_instance VI_1 {
state MASTER
interface ens33
virtual_router_id 41
priority 100
advert_int 1
authentication {
auth_type PASS
auth_pass 1111
}
virtual_ipaddress {
192.168.1.150
}
}

<span class="pl-c"><span class="pl-c">#</span> 配置集群访问的 ip+端口，端口和 nginx 保持一致</span>

virtual_server 192.168.1.150 80{ <span class="pl-c"><span class="pl-c">#</span>健康检查的时间，单位：秒</span>
delay_loop 6 <span class="pl-c"><span class="pl-c">#</span>配置负载均衡的算法，默认的轮询</span>
lb_algo rr <span class="pl-c"><span class="pl-c">#</span>设置 LVS 的模式 NAT|TUN|DR</span>
lb-kind DR <span class="pl-c"><span class="pl-c">#</span>设置会话持久化的时间</span>
persistence_timeout 5 <span class="pl-c"><span class="pl-c">#</span>协议</span>
protocol TCP

    <span class="pl-c"><span class="pl-c">#</span>配置负载均衡的真实服务器，也就是nginx节点的具体的ip地址</span>
    real_server 192.168.1.171 80{
        <span class="pl-c"><span class="pl-c">#</span>轮询权重配比</span>
        weight 1
        <span class="pl-c"><span class="pl-c">#</span>设置健康检查</span>
        TCP_CHECK {
            <span class="pl-c"><span class="pl-c">#</span>检查80端口</span>
            connect_port 80
            <span class="pl-c"><span class="pl-c">#</span>超时时间</span>
            connect_timeout 2
            <span class="pl-c"><span class="pl-c">#</span>重试次数</span>
            nb_get_retry 2
            <span class="pl-c"><span class="pl-c">#</span>重试间隔时间</span>
            delay_before_retry 3
        }
    }
    real_server 192.168.1.171 80{
        weight 1
        TCP_CHECK {
            connect_port 80
            connect_timeout 2
            nb_get_retry 2
            delay_before_retry 3
        }
    }

}</pre></div>
<p>(2)启动/重启 keepalived</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">systemctl restart keepalived</pre></div>
<h3>(2)使用 keepalived 配置 Backup LVS</h3>
<p>配置在备用机上</p>
<div class="highlight highlight-source-shell"><pre class="notranslate">global_defs {
router_id keep_152
}
vrrp_instance VI_1 {
state BACKUP
interface ens33
virtual_router_id 41
priority 50
advert_int 1
authentication {
auth_type PASS
auth_pass 1111
}
virtual_ipaddress {
192.168.1.150
}
}

<span class="pl-c"><span class="pl-c">#</span> 配置集群访问的 ip+端口，端口和 nginx 保持一致</span>

virtual_server 192.168.1.150 80{ <span class="pl-c"><span class="pl-c">#</span>健康检查的时间，单位：秒</span>
delay_loop 6 <span class="pl-c"><span class="pl-c">#</span>配置负载均衡的算法，默认的轮询</span>
lb_algo rr <span class="pl-c"><span class="pl-c">#</span>设置 LVS 的模式 NAT|TUN|DR</span>
lb-kind DR <span class="pl-c"><span class="pl-c">#</span>设置会话持久化的时间</span>
persistence_timeout 5 <span class="pl-c"><span class="pl-c">#</span>协议</span>
protocol TCP

    <span class="pl-c"><span class="pl-c">#</span>配置负载均衡的真实服务器，也就是nginx节点的具体的ip地址</span>
    real_server 192.168.1.171 80{
        <span class="pl-c"><span class="pl-c">#</span>轮询权重配比</span>
        weight 1
        <span class="pl-c"><span class="pl-c">#</span>设置健康检查</span>
        TCP_CHECK {
            <span class="pl-c"><span class="pl-c">#</span>检查80端口</span>
            connect_port 80
            <span class="pl-c"><span class="pl-c">#</span>超时时间</span>
            connect_timeout 2
            <span class="pl-c"><span class="pl-c">#</span>重试次数</span>
            nb_get_retry 2
            <span class="pl-c"><span class="pl-c">#</span>重试间隔时间</span>
            delay_before_retry 3
        }
    }
    real_server 192.168.1.171 80{
        weight 1
        TCP_CHECK {
            connect_port 80
            connect_timeout 2
            nb_get_retry 2
            delay_before_retry 3
        }
    }

}</pre></div>
<p>来源：blog.csdn.net/qq_34886352/article/details/103581973</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://mr-dzr.github.io/blogs">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","mr-dzr/blogs");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
